<!DOCTYPE html>
<html lang="en" class="h-full" x-bind:class="{ 'dark': darkMode }">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYNEU WebUI - AI Chat Interface</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#0969da',
                        secondary: '#6e7781',
                        dark: {
                            '900': '#15171a',
                            '800': '#1a1d21',
                            '700': '#22262b',
                            '600': '#2b3038',
                            '500': '#363b44',
                            'border': 'rgba(75, 85, 99, 0.15)'
                        }
                    },
                    fontFamily: {
                        'sans': ['Inter', 'system-ui', '-apple-system', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        .resize-handle {
            cursor: ew-resize;
            width: 4px;
            background: transparent;
            transition: background 0.2s;
        }
        .resize-handle:hover, .resize-handle.dragging {
            background: rgba(128, 128, 128, 0.2);
        }
        .user-select-none {
            user-select: none;
        }
        .custom-textarea {
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        .custom-textarea:hover {
            border-color: rgba(107, 114, 128, 0.2);
        }
        .dark .custom-textarea:hover {
            border-color: rgba(75, 85, 99, 0.2);
        }
        .custom-textarea:focus {
            outline: none;
        }
        .dark .custom-textarea:focus {
            outline: none;
        }
        .model-selector {
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        .model-selector:hover {
            background-color: rgba(107, 114, 128, 0.05);
        }
        .dark .model-selector:hover {
            background-color: rgba(75, 85, 99, 0.1);
        }
        .model-dropdown {
            backdrop-filter: blur(8px);
            border: 1px solid rgba(107, 114, 128, 0.1);
        }
        .dark .model-dropdown {
            border-color: rgba(75, 85, 99, 0.2);
        }
        .send-button {
            transition: all 0.2s ease;
        }
        /* ç¡®ä¿ä¾§è¾¹æ æ²¡æœ‰é˜´å½± */
        .sidebar-content {
            box-shadow: none !important;
        }
        /* æ¶ˆæ¯å†…å®¹æ ·å¼ä¼˜åŒ– */
        .prose {
            overflow-wrap: break-word;
            word-wrap: break-word;
        }
        .prose pre {
            max-width: 100%;
            overflow-x: auto;
        }
        .prose img {
            max-width: 100%;
            height: auto;
        }
        /* æ€è€ƒçŠ¶æ€åŠ¨ç”» */
        @keyframes thinking {
            0% { content: ''; }
            25% { content: '.'; }
            50% { content: '..'; }
            75% { content: '...'; }
        }
        .thinking::after {
            content: '';
            animation: thinking 1.5s steps(1) infinite;
        }
        .scroll-button {
            position: fixed;
            right: 2rem;
            padding: 0.625rem;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 0.5rem;
            color: rgba(107, 114, 128, 0.8);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
            z-index: 50;
            opacity: 0;
            visibility: hidden;
        }
        .scroll-button.visible {
            opacity: 1;
            visibility: visible;
        }
        .dark .scroll-button {
            background-color: rgba(43, 48, 56, 0.9);
            border-color: rgba(75, 85, 99, 0.2);
            color: rgba(156, 163, 175, 0.8);
        }
        .scroll-button:hover {
            background-color: rgba(255, 255, 255, 0.95);
            color: rgba(17, 24, 39, 0.95);
            transform: translateY(-1px);
        }
        .dark .scroll-button:hover {
            background-color: rgba(43, 48, 56, 0.95);
            color: rgba(229, 231, 235, 0.95);
        }
        .scroll-button.top {
            top: 5rem;
        }
        .scroll-button.bottom {
            bottom: 5rem;
        }
        .scroll-button svg {
            width: 1.25rem;
            height: 1.25rem;
            stroke-width: 2;
        }
    </style>
    <script src="https://unpkg.com/alpinejs" defer></script>
</head>
<body class="h-full transition-colors duration-200" 
    x-data="{ 
        sidebarOpen: true, 
        darkMode: localStorage.getItem('darkMode') === 'true' || (!('darkMode' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches),
        sidebarWidth: 256,
        isDragging: false,
        message: '',
        messages: [],
        chats: [],
        currentChatId: null,
        modelSelectorOpen: false,
        isThinking: false,
        selectedModel: localStorage.getItem('selectedModel') || 'DeepSeek-rlï¼š1.5b',
        models: ['DeepSeek-rlï¼š1.5b', 'Claude 3', 'GPT-4', 'Gemini Pro'],
        config: {
            apiUrl: 'http://localhost:8080'
        },
        showScrollButtons: false,
        toggleDarkMode() {
            this.darkMode = !this.darkMode;
            localStorage.setItem('darkMode', this.darkMode);
        },
        init() {
            this.$watch('darkMode', value => {
                if (value) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            });
            
            if (this.darkMode) {
                document.documentElement.classList.add('dark');
            }

            this.messages = [];
            this.loadInitialData();
            
            // æ·»åŠ æ»šåŠ¨ç›‘å¬
            this.$nextTick(() => {
                const chatContainer = this.$refs.chatContainer;
                if (chatContainer) {
                    chatContainer.addEventListener('scroll', () => this.checkScroll());
                    window.addEventListener('resize', () => this.checkScroll());
                    this.checkScroll();
                }
            });
        },
        async loadInitialData() {
            try {
                await this.loadModels();
                await this.loadChats();
                
                if (this.chats.length === 0) {
                    await this.createNewChat();
                } else {
                    this.currentChatId = this.chats[0].id;
                    await this.loadChatMessages(this.currentChatId);
                }
            } catch (error) {
                console.error('Failed to initialize:', error);
            }
        },
        async loadModels() {
            try {
                const response = await fetch(`${this.config.apiUrl}/api/models`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                this.models = data.models || [];
                if (this.models.length > 0) {
                    if (!localStorage.getItem('selectedModel') || !this.models.includes(this.selectedModel)) {
                        this.selectedModel = this.models[0];
                        localStorage.setItem('selectedModel', this.models[0]);
                    }
                }
            } catch (error) {
                console.error('Failed to load models:', error);
                this.models = [];
            }
        },
        async loadChats() {
            try {
                const response = await fetch(`${this.config.apiUrl}/api/chats`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                this.chats = data.chats || [];
            } catch (error) {
                console.error('Failed to load chats:', error);
                this.chats = [];
            }
        },
        async createNewChat() {
            try {
                if (!this.selectedModel) {
                    console.error('No model selected');
                    return;
                }

                const response = await fetch(`${this.config.apiUrl}/api/chats`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        title: 'New Chat',
                        model: this.selectedModel
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || `HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                this.chats.unshift(data.chat);
                this.currentChatId = data.chat.id;
                this.messages = [];
            } catch (error) {
                console.error('Failed to create chat:', error);
            }
        },
        async loadChatMessages(chatId) {
            try {
                const response = await fetch(`${this.config.apiUrl}/api/chats/${chatId}/messages`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                this.messages = data.messages || [];
            } catch (error) {
                console.error('Failed to load messages:', error);
                this.messages = [];
            }
        },
        async deleteChat(chatId) {
            try {
                const response = await fetch(`${this.config.apiUrl}/api/chats/${chatId}`, {
                    method: 'DELETE'
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                this.chats = this.chats.filter(chat => chat.id !== chatId);
                if (this.currentChatId === chatId) {
                    this.currentChatId = this.chats.length > 0 ? this.chats[0].id : null;
                    if (this.currentChatId) {
                        await this.loadChatMessages(this.currentChatId);
                    } else {
                        this.messages = [];
                    }
                }
            } catch (error) {
                console.error('Failed to delete chat:', error);
            }
        },
        scrollToBottom() {
            const chatContainer = this.$refs.chatContainer;
            if (chatContainer) {
                chatContainer.scrollTo({
                    top: chatContainer.scrollHeight,
                    behavior: 'smooth'
                });
            }
        },
        scrollToTop() {
            const chatContainer = this.$refs.chatContainer;
            if (chatContainer) {
                chatContainer.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            }
        },
        checkScroll() {
            const container = this.$refs.chatContainer;
            if (container) {
                const scrollTop = container.scrollTop;
                const scrollHeight = container.scrollHeight;
                const clientHeight = container.clientHeight;
                
                // åªæœ‰å½“å†…å®¹é«˜åº¦è¶…è¿‡å®¹å™¨é«˜åº¦ 100px æ—¶æ‰æ˜¾ç¤ºæŒ‰é’®
                this.showScrollButtons = scrollHeight > clientHeight + 100;
            }
        },
        async sendMessage() {
            if (!this.message.trim() || !this.currentChatId) return;

            const messageContent = this.message.trim();
            const userMessage = {
                role: 'user',
                content: messageContent
            };
            this.messages.push(userMessage);
            this.message = '';

            // ç«‹å³æ·»åŠ ä¸€ä¸ªç©ºçš„åŠ©æ‰‹æ¶ˆæ¯å¹¶è®¾ç½®æ€è€ƒçŠ¶æ€
            const aiMessage = { role: 'assistant', content: '' };
            this.messages.push(aiMessage);
            this.isThinking = true;

            // ç¡®ä¿æ»šåŠ¨åˆ°åº•éƒ¨
            await this.$nextTick();
            this.scrollToBottom();

            // Auto rename chat if it's the first message
            if (this.messages.length === 2) {  // ç°åœ¨æ˜¯2ï¼Œå› ä¸ºåŒ…å«äº†ç©ºçš„åŠ©æ‰‹æ¶ˆæ¯
                const title = messageContent.length > 50 ? messageContent.substring(0, 47) + '...' : messageContent;
                await this.renameChat(this.currentChatId, title);
            }

            try {
                const response = await fetch(`${this.config.apiUrl}/api/chat/${this.currentChatId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        content: messageContent,
                        model: this.selectedModel
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const messageIndex = this.messages.length - 1;
                const messageContainer = document.getElementById(`message-${messageIndex}`);
                
                if (!messageContainer) {
                    throw new Error('Message container not found');
                }
                
                const contentElement = messageContainer.querySelector('.prose');
                if (!contentElement) {
                    throw new Error('Content element not found');
                }

                const decoder = new TextDecoder();
                let buffer = '';
                let hasStartedResponse = false;

                const reader = response.body.getReader();

                const updateContent = async (content) => {
                    try {
                        if (!hasStartedResponse) {
                            hasStartedResponse = true;
                            this.isThinking = false;
                        }
                        const rendered = this.renderMarkdown(content);
                        await this.$nextTick();
                        contentElement.innerHTML = rendered;
                        this.scrollToBottom();
                    } catch (error) {
                        console.error('Error updating content:', error);
                    }
                };

                try {
                    while (true) {
                        const { value, done } = await reader.read();
                        
                        if (done) {
                            if (buffer) {
                                aiMessage.content = buffer;
                                await updateContent(buffer);
                            }
                            break;
                        }

                        const chunk = decoder.decode(value, { stream: true });
                        buffer += chunk;
                        aiMessage.content = buffer;
                        await updateContent(buffer);
                    }
                } finally {
                    reader.releaseLock();
                    this.isThinking = false;
                }
            } catch (error) {
                console.error('Error in sendMessage:', error);
                this.messages.pop(); // ç§»é™¤ç©ºçš„åŠ©æ‰‹æ¶ˆæ¯
                this.messages.push({
                    role: 'system',
                    content: `Error: ${error.message}`
                });
                
                this.isThinking = false;
                await this.$nextTick();
                this.scrollToBottom();
            }
        },
        renderMarkdown(content) {
            if (!content) return '';
            try {
                if (window.marked) {
                    marked.setOptions({
                        breaks: true,
                        gfm: true,
                        sanitize: false,
                        smartLists: true,
                        smartypants: true
                    });
                    return marked.parse(content);
                }
                return content;
            } catch (error) {
                console.error('Markdown rendering error:', error);
                return content;
            }
        },
        startDrag(e) {
            this.isDragging = true;
            this.startX = e.pageX;
            this.startWidth = this.sidebarWidth;
            document.body.classList.add('user-select-none');
        },
        doDrag(e) {
            if (!this.isDragging) return;
            const delta = e.pageX - this.startX;
            const newWidth = Math.min(Math.max(this.startWidth + delta, 256), window.innerWidth * 0.8);
            this.sidebarWidth = newWidth;
        },
        stopDrag() {
            this.isDragging = false;
            document.body.classList.remove('user-select-none');
        },
        async renameChat(chatId, newTitle) {
            if (!newTitle.trim()) return;
            
            try {
                const response = await fetch(`${this.config.apiUrl}/api/chats/${chatId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        title: newTitle.trim()
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                const chatIndex = this.chats.findIndex(c => c.id === chatId);
                if (chatIndex !== -1) {
                    this.chats[chatIndex].title = data.chat.title;
                }
            } catch (error) {
                console.error('Failed to rename chat:', error);
            }
        }
    }" 
    @mousemove.window="doDrag($event)" 
    @mouseup.window="stopDrag()"
    :class="{ 'bg-gray-50 dark:bg-dark-900': true }"
>
    <div class="min-h-full">
        <!-- Top Navigation -->
        <nav class="bg-white dark:bg-dark-800 shadow-sm border-b border-gray-200 dark:border-dark-border">
            <div class="mx-auto px-4">
                <div class="flex h-16 items-center">
                    <!-- Left section: Sidebar toggle and Title -->
                    <div class="flex items-center space-x-4">
                        <button @click="sidebarOpen = !sidebarOpen" 
                            class="text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 -ml-2 p-2 rounded-lg transition-colors duration-200"
                        >
                            <svg class="h-5 w-5 transition-transform duration-300 ease-in-out" 
                                fill="none" 
                                viewBox="0 0 24 24" 
                                stroke="currentColor" 
                                :class="{ 'rotate-90': !sidebarOpen }"
                            >
                                <path stroke-linecap="round" 
                                    stroke-linejoin="round" 
                                    stroke-width="1.75" 
                                    d="M8 7v10m4-10v10m4-10v10" 
                                />
                            </svg>
                        </button>
                        <div class="flex items-center">
                            <h1 class="text-xl tracking-tight">
                                <span class="font-semibold bg-gradient-to-r from-primary to-purple-600 bg-clip-text text-transparent">CYNEU </span>
                                <span class="font-medium text-gray-700 dark:text-gray-200"> WebUI</span>
                            </h1>
                        </div>
                    </div>

                    <div class="flex-1"></div>

                    <!-- Right section with theme toggle -->
                    <div class="flex items-center">
                        <button 
                            @click="toggleDarkMode()" 
                            class="rounded-lg p-2 text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700"
                            :aria-label="darkMode ? 'Switch to light mode' : 'Switch to dark mode'"
                        >
                            <svg x-show="!darkMode" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                            </svg>
                            <svg x-show="darkMode" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Main Content Area -->
        <div class="flex h-[calc(100vh-4rem)]">
            <!-- Sidebar with resize handle -->
            <div x-show="sidebarOpen" 
                 class="flex"
                 x-transition:enter="transition ease-out duration-300"
                 x-transition:enter-start="-translate-x-full"
                 x-transition:enter-end="translate-x-0"
                 x-transition:leave="transition ease-in duration-300"
                 x-transition:leave-start="translate-x-0"
                 x-transition:leave-end="-translate-x-full">
                <!-- Sidebar content -->
                <div :style="'width: ' + sidebarWidth + 'px'" class="sidebar-content flex-shrink-0 border-r border-gray-200 dark:border-dark-border bg-white dark:bg-dark-800">
                    <div class="h-full px-3 py-4">
                        <div class="space-y-2">
                            <button 
                                @click="createNewChat()"
                                class="w-full flex items-center px-3 py-2 text-sm font-medium rounded-md bg-gray-100 dark:bg-dark-600 text-gray-900 dark:text-white">
                                <svg class="mr-3 h-5 w-5 text-gray-500 dark:text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                                </svg>
                                æ–°å¯¹è¯
                            </button>
                            <div class="border-b border-gray-200 dark:border-dark-border my-4 opacity-50"></div>
                            <div class="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider px-3 mb-2">
                                æœ€è¿‘å¯¹è¯
                            </div>
                            <div class="space-y-1">
                                <template x-for="chat in chats" :key="chat.id">
                                    <a 
                                        href="#" 
                                        @click.prevent="currentChatId = chat.id; loadChatMessages(chat.id)"
                                        class="flex items-center px-3 py-2 text-sm rounded-md text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-dark-600"
                                        :class="{ 'bg-gray-100 dark:bg-dark-600': currentChatId === chat.id }"
                                    >
                                        <div class="flex-1 min-w-0" x-data="{ isEditing: false }">
                                            <div x-show="!isEditing" class="truncate" @dblclick="isEditing = true" x-text="chat.title"></div>
                                            <input
                                                x-show="isEditing"
                                                type="text"
                                                class="w-full px-1 py-0.5 text-sm bg-white dark:bg-dark-700 border border-gray-300 dark:border-dark-500 rounded"
                                                :value="chat.title"
                                                @blur="isEditing = false"
                                                @keydown.enter="renameChat(chat.id, $event.target.value); isEditing = false"
                                                @click.stop
                                            >
                                        </div>
                                        <button 
                                            @click.stop="deleteChat(chat.id)"
                                            class="ml-2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                                        >
                                            <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                            </svg>
                                        </button>
                                    </a>
                                </template>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Resize handle -->
                <div class="resize-handle h-full" 
                     :class="{ 'dragging': isDragging }"
                     @mousedown="startDrag($event)">
                </div>
            </div>

            <!-- Chat Area -->
            <div class="flex-1 flex flex-col bg-white dark:bg-dark-800 overflow-hidden relative">
                <!-- æ»šåŠ¨æŒ‰é’® -->
                <button 
                    @click="scrollToTop"
                    class="scroll-button top"
                    :class="{ 'visible': showScrollButtons }"
                    title="æ»šåŠ¨åˆ°é¡¶éƒ¨"
                >
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M5 10l7-7m0 0l7 7m-7-7v18" />
                    </svg>
                </button>
                <button 
                    @click="scrollToBottom"
                    class="scroll-button bottom"
                    :class="{ 'visible': showScrollButtons }"
                    title="æ»šåŠ¨åˆ°åº•éƒ¨"
                >
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
                    </svg>
                </button>

                <div class="flex-1 overflow-y-auto px-4 py-6 sm:px-6" 
                     x-ref="chatContainer"
                     @scroll.passive="checkScroll">
                    <!-- Welcome message for empty chat -->
                    <template x-if="messages.length === 0">
                        <div class="max-w-3xl mx-auto">
                            <div class="text-center mb-8">
                                <div class="inline-flex items-center justify-center w-16 h-16 rounded-full bg-gradient-to-br from-blue-500 via-purple-500 to-pink-500 mb-4">
                                    <svg class="w-8 h-8 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-4l-4 4-4-4z" />
                                    </svg>
                                </div>
                                <h2 class="text-2xl font-semibold text-gray-900 dark:text-white mb-2">æ¬¢è¿ä½¿ç”¨ CYNEU WebUI</h2>
                                <p class="text-gray-600 dark:text-gray-400 mb-6">æˆ‘æ˜¯æ‚¨çš„ AI åŠ©æ‰‹ï¼Œè®©æˆ‘ä»¬å¼€å§‹å¯¹è¯å§</p>
                            </div>

                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-8">
                                <div class="p-4 rounded-lg border border-gray-200 dark:border-dark-600 hover:border-primary dark:hover:border-primary transition-colors duration-200">
                                    <h3 class="font-medium text-gray-900 dark:text-white mb-2">ğŸ’¡ åŠŸèƒ½ä»‹ç»</h3>
                                    <ul class="text-sm text-gray-600 dark:text-gray-400 space-y-2">
                                        <li>â€¢ æ”¯æŒå¤šç§å¤§è¯­è¨€æ¨¡å‹</li>
                                        <li>â€¢ å®æ—¶å¯¹è¯å“åº”</li>
                                        <li>â€¢ Markdown æ¸²æŸ“</li>
                                        <li>â€¢ ä»£ç é«˜äº®æ˜¾ç¤º</li>
                                    </ul>
                                </div>
                                <div class="p-4 rounded-lg border border-gray-200 dark:border-dark-600 hover:border-primary dark:hover:border-primary transition-colors duration-200">
                                    <h3 class="font-medium text-gray-900 dark:text-white mb-2">âš¡ï¸ å¿«æ·æ“ä½œ</h3>
                                    <ul class="text-sm text-gray-600 dark:text-gray-400 space-y-2">
                                        <li>â€¢ Enter å‘é€æ¶ˆæ¯</li>
                                        <li>â€¢ Shift + Enter æ¢è¡Œ</li>
                                        <li>â€¢ åŒå‡»èŠå¤©æ ‡é¢˜å¯é‡å‘½å</li>
                                        <li>â€¢ æ‹–åŠ¨ä¾§è¾¹æ è°ƒæ•´å®½åº¦</li>
                                    </ul>
                                </div>
                            </div>

                            <div class="space-y-4">
                                <h3 class="text-sm font-medium text-gray-900 dark:text-white mb-3">ğŸ¯ æ‚¨å¯ä»¥è¿™æ ·é—®æˆ‘</h3>
                                <div class="grid grid-cols-1 gap-3">
                                    <button @click="message = 'èƒ½å¦å¸®æˆ‘åˆ†æä¸€ä¸‹äººå·¥æ™ºèƒ½åœ¨æœªæ¥åŒ»ç–—é¢†åŸŸçš„åº”ç”¨å‰æ™¯ï¼Ÿç‰¹åˆ«æ˜¯åœ¨ç–¾ç—…è¯Šæ–­ã€ä¸ªæ€§åŒ–æ²»ç–—å’Œè¯ç‰©ç ”å‘æ–¹é¢ã€‚'; sendMessage()" 
                                        class="text-left p-3 rounded-lg bg-gray-50 dark:bg-dark-700 hover:bg-gray-100 dark:hover:bg-dark-600 text-gray-600 dark:text-gray-300 text-sm transition-colors duration-200">
                                        èƒ½å¦å¸®æˆ‘åˆ†æä¸€ä¸‹äººå·¥æ™ºèƒ½åœ¨æœªæ¥åŒ»ç–—é¢†åŸŸçš„åº”ç”¨å‰æ™¯ï¼Ÿç‰¹åˆ«æ˜¯åœ¨ç–¾ç—…è¯Šæ–­ã€ä¸ªæ€§åŒ–æ²»ç–—å’Œè¯ç‰©ç ”å‘æ–¹é¢ã€‚
                                    </button>
                                    <button @click="message = 'è¯·ä»‹ç»ä¸€ä¸‹é‡å­è®¡ç®—æœºçš„å·¥ä½œåŸç†ï¼Œä»¥åŠå®ƒå¯èƒ½ç»™æˆ‘ä»¬çš„ç”Ÿæ´»å¸¦æ¥å“ªäº›é©å‘½æ€§çš„æ”¹å˜ï¼Ÿ'; sendMessage()" 
                                        class="text-left p-3 rounded-lg bg-gray-50 dark:bg-dark-700 hover:bg-gray-100 dark:hover:bg-dark-600 text-gray-600 dark:text-gray-300 text-sm transition-colors duration-200">
                                        è¯·ä»‹ç»ä¸€ä¸‹é‡å­è®¡ç®—æœºçš„å·¥ä½œåŸç†ï¼Œä»¥åŠå®ƒå¯èƒ½ç»™æˆ‘ä»¬çš„ç”Ÿæ´»å¸¦æ¥å“ªäº›é©å‘½æ€§çš„æ”¹å˜ï¼Ÿ
                                    </button>
                                    <button @click="message = 'å¯å†ç”Ÿèƒ½æºæŠ€æœ¯å¦‚ä½•å¸®åŠ©è§£å†³å…¨çƒæ°”å€™å˜åŒ–é—®é¢˜ï¼Ÿæœªæ¥æ¸…æ´èƒ½æºå‘å±•çš„ä¸»è¦æ–¹å‘æ˜¯ä»€ä¹ˆï¼Ÿ'; sendMessage()" 
                                        class="text-left p-3 rounded-lg bg-gray-50 dark:bg-dark-700 hover:bg-gray-100 dark:hover:bg-dark-600 text-gray-600 dark:text-gray-300 text-sm transition-colors duration-200">
                                        å¯å†ç”Ÿèƒ½æºæŠ€æœ¯å¦‚ä½•å¸®åŠ©è§£å†³å…¨çƒæ°”å€™å˜åŒ–é—®é¢˜ï¼Ÿæœªæ¥æ¸…æ´èƒ½æºå‘å±•çš„ä¸»è¦æ–¹å‘æ˜¯ä»€ä¹ˆï¼Ÿ
                                    </button>
                                </div>
                            </div>
                        </div>
                    </template>

                    <template x-for="(message, index) in messages" :key="index">
                        <div :class="{'flex space-x-3 mb-6': true, 'justify-end': message.role === 'user'}" :id="'message-' + index">
                            <template x-if="message.role === 'assistant'">
                                <div class="flex-shrink-0">
                                    <div class="h-8 w-8 rounded-full bg-gradient-to-br from-blue-500 via-purple-500 to-pink-500 flex items-center justify-center shadow-lg">
                                        <svg class="h-4 w-4 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                                d="M12 6C8.68629 6 6 8.68629 6 12C6 13.5 6.5 14.5 7.5 15.5C8.5 16.5 9.5 17 11 17C11.5 17 12 16.8 12 16.5C12 16.2 11.8 16 11.5 16C10.3 16 9.5 15.5 8.8 14.8C8.1 14.1 7.7 13.3 7.7 12C7.7 9.6 9.6 7.7 12 7.7C14.4 7.7 16.3 9.6 16.3 12C16.3 13.3 15.9 14.1 15.2 14.8C14.5 15.5 13.7 16 12.5 16C12.2 16 12 16.2 12 16.5C12 16.8 12.5 17 13 17C14.5 17 15.5 16.5 16.5 15.5C17.5 14.5 18 13.5 18 12C18 8.68629 15.3137 6 12 6Z" />
                                        </svg>
                                    </div>
                                </div>
                            </template>
                            
                            <div :class="{'flex-1': true, 'flex justify-end': message.role === 'user'}">
                                <div :class="{
                                    'rounded-lg px-4 py-3 max-w-3xl': true,
                                    'bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-gray-100': message.role === 'assistant',
                                    'bg-primary text-white': message.role === 'user'
                                }">
                                    <div x-html="renderMarkdown(message.content)" class="prose dark:prose-invert max-w-none"></div>
                                    <div x-show="message.role === 'assistant' && isThinking && !message.content" 
                                         class="text-sm text-gray-500 dark:text-gray-400 thinking">
                                        æ€è€ƒä¸­
                                    </div>
                                </div>
                            </div>

                            <template x-if="message.role === 'user'">
                                <div class="flex-shrink-0">
                                    <div class="h-8 w-8 rounded-full bg-gradient-to-br from-green-400 via-emerald-500 to-teal-500 flex items-center justify-center shadow-lg">
                                        <svg class="h-4 w-4 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                                        </svg>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </template>
                </div>

                <!-- Input Area -->
                <div class="flex-shrink-0 px-4 py-4 border-t border-gray-200 dark:border-dark-700">
                    <div class="max-w-[80%] mx-auto">
                        <form @submit.prevent="sendMessage">
                            <div class="space-y-3">
                                <div class="relative">
                                    <textarea
                                        x-model="message"
                                        @keydown.enter="$event.shiftKey ? null : ($event.preventDefault(), sendMessage())"
                                        rows="2"
                                        class="custom-textarea block w-full rounded-lg pl-4 pr-12 py-3 border-0 text-gray-900 dark:text-gray-100 shadow-sm ring-1 ring-inset ring-gray-300 dark:ring-dark-600 placeholder:text-gray-400 focus:ring-2 focus:ring-primary sm:text-sm sm:leading-6 bg-white dark:bg-dark-900 resize-none"
                                        placeholder="è¾“å…¥æ‚¨çš„æ¶ˆæ¯... (Enter å‘é€, Shift+Enter æ¢è¡Œ)"
                                        style="min-height: 64px; max-height: 200px;"
                                        @input="$el.style.height = '64px'; $el.style.height = $el.scrollHeight + 'px'"
                                    ></textarea>
                                    <button
                                        type="submit"
                                        :disabled="!message.trim()"
                                        class="absolute right-2 bottom-2 inline-flex items-center rounded-lg px-2 py-2 text-primary hover:bg-gray-50 dark:hover:bg-dark-700 disabled:opacity-50 disabled:cursor-not-allowed"
                                    >
                                        <svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                        </svg>
                                    </button>
                                </div>

                                <!-- Model Selector -->
                                <div class="relative">
                                    <button 
                                        type="button" 
                                        class="model-selector inline-flex items-center gap-x-1.5 rounded-md px-2 py-1 text-xs text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200"
                                        @click="modelSelectorOpen = !modelSelectorOpen"
                                    >
                                        <svg class="h-3.5 w-3.5 text-gray-400 dark:text-gray-500" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 12h18M9 6l-6 6 6 6M21 6l-6 6 6 6" />
                                        </svg>
                                        <span x-text="selectedModel" class="font-medium"></span>
                                        <svg class="h-3.5 w-3.5 text-gray-400 dark:text-gray-500 transition-transform duration-200" 
                                             :class="{ 'rotate-180': modelSelectorOpen }"
                                             viewBox="0 0 24 24" 
                                             fill="none" 
                                             stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M19 9l-7 7-7-7" />
                                        </svg>
                                    </button>

                                    <!-- Model Dropdown -->
                                    <div 
                                        x-show="modelSelectorOpen" 
                                        @click.away="modelSelectorOpen = false"
                                        class="model-dropdown absolute bottom-full mb-1 left-0 z-10 w-40 rounded-lg bg-white/95 dark:bg-dark-800/95 shadow-lg focus:outline-none overflow-hidden"
                                        x-transition:enter="transition ease-out duration-200"
                                        x-transition:enter-start="opacity-0 scale-95"
                                        x-transition:enter-end="opacity-100 scale-100"
                                        x-transition:leave="transition ease-in duration-150"
                                        x-transition:leave-start="opacity-100 scale-100"
                                        x-transition:leave-end="opacity-0 scale-95"
                                    >
                                        <div class="py-1">
                                            <template x-for="model in models" :key="model">
                                                <a 
                                                    href="#" 
                                                    class="block px-3 py-1.5 text-xs text-gray-600 dark:text-gray-400 hover:bg-gray-50/80 dark:hover:bg-dark-600/80 transition-colors duration-150" 
                                                    :class="{ 'bg-gray-50/80 dark:bg-dark-600/80 text-gray-900 dark:text-white font-medium': model === selectedModel }"
                                                    @click.prevent="selectedModel = model; localStorage.setItem('selectedModel', model); modelSelectorOpen = false"
                                                    x-text="model"
                                                ></a>
                                            </template>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Initialize Alpine.js data -->
    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('app', () => ({
                config: {
                    apiUrl: 'http://localhost:8080'
                },
                sidebarOpen: true,
                darkMode: localStorage.getItem('darkMode') === 'true' || (!('darkMode' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches),
                sidebarWidth: 256,
                isDragging: false,
                message: '',
                messages: [],
                chats: [],
                currentChatId: null,
                modelSelectorOpen: false,
                isThinking: false,
                selectedModel: localStorage.getItem('selectedModel') || 'DeepSeek-rlï¼š1.5b',
                models: ['DeepSeek-rlï¼š1.5b', 'Claude 3', 'GPT-4', 'Gemini Pro'],
                showScrollButtons: false,

                init() {
                    this.$watch('darkMode', value => {
                        if (value) {
                            document.documentElement.classList.add('dark');
                        } else {
                            document.documentElement.classList.remove('dark');
                        }
                    });
                    
                    if (this.darkMode) {
                        document.documentElement.classList.add('dark');
                    }

                    this.loadInitialData();
                    
                    // æ·»åŠ æ»šåŠ¨ç›‘å¬
                    this.$nextTick(() => {
                        const chatContainer = this.$refs.chatContainer;
                        if (chatContainer) {
                            chatContainer.addEventListener('scroll', () => this.checkScroll());
                            window.addEventListener('resize', () => this.checkScroll());
                            this.checkScroll();
                        }
                    });
                },

                async loadInitialData() {
                    try {
                        await this.loadModels();
                        await this.loadChats();
                        
                        if (this.chats.length === 0) {
                            await this.createNewChat();
                        } else {
                            this.currentChatId = this.chats[0].id;
                            await this.loadChatMessages(this.currentChatId);
                        }
                    } catch (error) {
                        console.error('Failed to initialize:', error);
                    }
                },

                async loadModels() {
                    try {
                        const response = await fetch(`${this.config.apiUrl}/api/models`);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        this.models = data.models || [];
                        if (this.models.length > 0) {
                            if (!localStorage.getItem('selectedModel') || !this.models.includes(this.selectedModel)) {
                                this.selectedModel = this.models[0];
                                localStorage.setItem('selectedModel', this.models[0]);
                            }
                        }
                    } catch (error) {
                        console.error('Failed to load models:', error);
                        this.models = [];
                    }
                },

                async loadChats() {
                    try {
                        const response = await fetch(`${this.config.apiUrl}/api/chats`);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        this.chats = data.chats || [];
                    } catch (error) {
                        console.error('Failed to load chats:', error);
                        this.chats = [];
                    }
                },

                async createNewChat() {
                    try {
                        if (!this.selectedModel) {
                            console.error('No model selected');
                            return;
                        }

                        const response = await fetch(`${this.config.apiUrl}/api/chats`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                title: 'New Chat',
                                model: this.selectedModel
                            })
                        });
                        
                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.detail || `HTTP error! status: ${response.status}`);
                        }

                        const data = await response.json();
                        this.chats.unshift(data.chat);
                        this.currentChatId = data.chat.id;
                        this.messages = [];
                    } catch (error) {
                        console.error('Failed to create chat:', error);
                    }
                },

                async loadChatMessages(chatId) {
                    try {
                        const response = await fetch(`${this.config.apiUrl}/api/chats/${chatId}/messages`);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        this.messages = data.messages || [];
                    } catch (error) {
                        console.error('Failed to load messages:', error);
                        this.messages = [];
                    }
                },

                async deleteChat(chatId) {
                    try {
                        const response = await fetch(`${this.config.apiUrl}/api/chats/${chatId}`, {
                            method: 'DELETE'
                        });
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        this.chats = this.chats.filter(chat => chat.id !== chatId);
                        if (this.currentChatId === chatId) {
                            this.currentChatId = this.chats.length > 0 ? this.chats[0].id : null;
                            if (this.currentChatId) {
                                await this.loadChatMessages(this.currentChatId);
                            } else {
                                this.messages = [];
                            }
                        }
                    } catch (error) {
                        console.error('Failed to delete chat:', error);
                    }
                },

                scrollToBottom() {
                    const chatContainer = this.$refs.chatContainer;
                    if (chatContainer) {
                        chatContainer.scrollTo({
                            top: chatContainer.scrollHeight,
                            behavior: 'smooth'
                        });
                    }
                },

                scrollToTop() {
                    const chatContainer = this.$refs.chatContainer;
                    if (chatContainer) {
                        chatContainer.scrollTo({
                            top: 0,
                            behavior: 'smooth'
                        });
                    }
                },

                checkScroll() {
                    const container = this.$refs.chatContainer;
                    if (container) {
                        const scrollTop = container.scrollTop;
                        const scrollHeight = container.scrollHeight;
                        const clientHeight = container.clientHeight;
                        
                        // åªæœ‰å½“å†…å®¹é«˜åº¦è¶…è¿‡å®¹å™¨é«˜åº¦ 100px æ—¶æ‰æ˜¾ç¤ºæŒ‰é’®
                        this.showScrollButtons = scrollHeight > clientHeight + 100;
                    }
                },

                async sendMessage() {
                    if (!this.message.trim() || !this.currentChatId) return;

                    const messageContent = this.message.trim();
                    const userMessage = {
                        role: 'user',
                        content: messageContent
                    };
                    this.messages.push(userMessage);
                    this.message = '';

                    // ç«‹å³æ·»åŠ ä¸€ä¸ªç©ºçš„åŠ©æ‰‹æ¶ˆæ¯å¹¶è®¾ç½®æ€è€ƒçŠ¶æ€
                    const aiMessage = { role: 'assistant', content: '' };
                    this.messages.push(aiMessage);
                    this.isThinking = true;

                    // ç¡®ä¿æ»šåŠ¨åˆ°åº•éƒ¨
                    await this.$nextTick();
                    this.scrollToBottom();

                    // Auto rename chat if it's the first message
                    if (this.messages.length === 2) {  // ç°åœ¨æ˜¯2ï¼Œå› ä¸ºåŒ…å«äº†ç©ºçš„åŠ©æ‰‹æ¶ˆæ¯
                        const title = messageContent.length > 50 ? messageContent.substring(0, 47) + '...' : messageContent;
                        await this.renameChat(this.currentChatId, title);
                    }

                    try {
                        const response = await fetch(`${this.config.apiUrl}/api/chat/${this.currentChatId}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                content: messageContent,
                                model: this.selectedModel
                            })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const messageIndex = this.messages.length - 1;
                        const messageContainer = document.getElementById(`message-${messageIndex}`);
                        
                        if (!messageContainer) {
                            throw new Error('Message container not found');
                        }
                        
                        const contentElement = messageContainer.querySelector('.prose');
                        if (!contentElement) {
                            throw new Error('Content element not found');
                        }

                        const decoder = new TextDecoder();
                        let buffer = '';
                        let hasStartedResponse = false;

                        const reader = response.body.getReader();

                        const updateContent = async (content) => {
                            try {
                                if (!hasStartedResponse) {
                                    hasStartedResponse = true;
                                    this.isThinking = false;
                                }
                                const rendered = this.renderMarkdown(content);
                                await this.$nextTick();
                                contentElement.innerHTML = rendered;
                                this.scrollToBottom();
                            } catch (error) {
                                console.error('Error updating content:', error);
                            }
                        };

                        try {
                            while (true) {
                                const { value, done } = await reader.read();
                                
                                if (done) {
                                    if (buffer) {
                                        aiMessage.content = buffer;
                                        await updateContent(buffer);
                                    }
                                    break;
                                }

                                const chunk = decoder.decode(value, { stream: true });
                                buffer += chunk;
                                aiMessage.content = buffer;
                                await updateContent(buffer);
                            }
                        } finally {
                            reader.releaseLock();
                            this.isThinking = false;
                        }
                    } catch (error) {
                        console.error('Error in sendMessage:', error);
                        this.messages.pop(); // ç§»é™¤ç©ºçš„åŠ©æ‰‹æ¶ˆæ¯
                        this.messages.push({
                            role: 'system',
                            content: `Error: ${error.message}`
                        });
                        
                        this.isThinking = false;
                        await this.$nextTick();
                        this.scrollToBottom();
                    }
                },

                renderMarkdown(content) {
                    if (!content) return '';
                    try {
                        if (window.marked) {
                            marked.setOptions({
                                breaks: true,
                                gfm: true,
                                sanitize: false,
                                smartLists: true,
                                smartypants: true
                            });
                            return marked.parse(content);
                        }
                        return content;
                    } catch (error) {
                        console.error('Markdown rendering error:', error);
                        return content;
                    }
                },

                toggleDarkMode() {
                    this.darkMode = !this.darkMode;
                    localStorage.setItem('darkMode', this.darkMode);
                },

                startDrag(e) {
                    this.isDragging = true;
                    this.startX = e.pageX;
                    this.startWidth = this.sidebarWidth;
                    document.body.classList.add('user-select-none');
                },

                doDrag(e) {
                    if (!this.isDragging) return;
                    const delta = e.pageX - this.startX;
                    const newWidth = Math.min(Math.max(this.startWidth + delta, 256), window.innerWidth * 0.8);
                    this.sidebarWidth = newWidth;
                },

                stopDrag() {
                    this.isDragging = false;
                    document.body.classList.remove('user-select-none');
                },

                async renameChat(chatId, newTitle) {
                    if (!newTitle.trim()) return;
                    
                    try {
                        const response = await fetch(`${this.config.apiUrl}/api/chats/${chatId}`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                title: newTitle.trim()
                            })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const data = await response.json();
                        const chatIndex = this.chats.findIndex(c => c.id === chatId);
                        if (chatIndex !== -1) {
                            this.chats[chatIndex].title = data.chat.title;
                        }
                    } catch (error) {
                        console.error('Failed to rename chat:', error);
                    }
                }
            }));
        });
    </script>
</body>
</html> 